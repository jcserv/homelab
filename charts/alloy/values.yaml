alloy:
  # Alloy configuration
  alloy:
    # Clustering - disabled for simplicity
    clustering:
      enabled: false

    # Configuration file
    configMap:
      create: true
      content: |-
        // Logging configuration
        logging {
          level  = "info"
          format = "logfmt"
        }

        // Discover Kubernetes pods
        discovery.kubernetes "pods" {
          role = "pod"

          // Only discover pods on this node to reduce CPU usage
          selectors {
            role  = "pod"
            field = "spec.nodeName=" + env("HOSTNAME")
          }
        }

        // Discover Kubernetes nodes
        discovery.kubernetes "nodes" {
          role = "node"
        }

        // Relabel pod logs
        discovery.relabel "pod_logs" {
          targets = discovery.kubernetes.pods.targets

          // Only scrape running pods
          rule {
            source_labels = ["__meta_kubernetes_pod_phase"]
            action        = "keep"
            regex         = "Running"
          }

          // Drop loki gateway access logs (noisy, creates unnecessary volume)
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            action        = "drop"
            regex         = "loki-gateway.*"
          }

          // Set namespace label
          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            target_label  = "namespace"
          }

          // Set pod name label
          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            target_label  = "pod"
          }

          // Set container name label
          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            target_label  = "container"
          }

          // Set job label to namespace/pod
          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_name"]
            separator     = "/"
            target_label  = "job"
          }

          // Set node name label
          rule {
            source_labels = ["__meta_kubernetes_pod_node_name"]
            target_label  = "node_name"
          }

          // Set log path
          rule {
            source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
            separator     = "/"
            target_label  = "__path__"
            replacement   = "/var/log/pods/*$1/*.log"
          }
        }

        // Scrape pod logs
        loki.source.kubernetes "pod_logs" {
          targets    = discovery.relabel.pod_logs.output
          forward_to = [loki.process.pod_logs.receiver]
        }

        // Process pod logs
        loki.process "pod_logs" {
          // Extract log level if present
          stage.regex {
            expression = "(?i)(?P<level>(debug|info|warn|error|fatal|panic))"
          }

          stage.labels {
            values = {
              level = "",
            }
          }

          forward_to = [loki.write.default.receiver]
        }

        // Write logs to Loki
        loki.write "default" {
          endpoint {
            url = "http://loki-gateway.monitoring.svc.cluster.local/loki/api/v1/push"

            // Batching configuration - optimized for memory usage
            batch_wait = "10s"  // Increased to send less frequently
            batch_size = "2MiB"  // Larger batches, fewer sends

            // Queue configuration to limit memory usage
            queue_config {
              capacity = "3MiB"  // Reduced from 10MiB default to limit buffering
            }
          }

          external_labels = {
            cluster = "homelab",
          }

          // Limit number of active log streams to prevent unbounded memory growth
          max_streams = 3000
        }

        // Prometheus remote write for collected metrics
        prometheus.remote_write "default" {
          endpoint {
            url = "http://prometheus-kube-prometheus-stack-prometheus.monitoring.svc.cluster.local:9090/api/v1/write"

            queue_config {
              capacity             = 1000  // Reduced from 2500 to limit memory
              max_shards           = 5
              min_shards           = 1
              max_samples_per_send = 500   // Reduced from 1000 to limit memory
              batch_send_deadline  = "5s"
              min_backoff          = "30ms"
              max_backoff          = "5s"
            }
          }
        }

        // Discover Prometheus service monitors
        // Scoped to specific namespaces to reduce cluster-wide API calls
        prometheus.operator.servicemonitors "default" {
          namespaces   = ["monitoring", "default", "kube-system"]
          forward_to   = [prometheus.remote_write.default.receiver]
        }

  # Controller settings
  controller:
    type: daemonset  # Run on every node to collect logs

    # Host paths for reading pod logs
    volumes:
      extra:
        - name: varlog
          hostPath:
            path: /var/log
        - name: varlibdockercontainers
          hostPath:
            path: /var/lib/docker/containers

    volumeMounts:
      extra:
        - name: varlog
          mountPath: /var/log
          readOnly: true
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true

    # Tolerations to run on all nodes including control plane
    tolerations:
      - effect: NoSchedule
        operator: Exists

  # Resources - updated to realistic values based on actual usage
  resources:
    requests:
      cpu: 100m
      memory: 512Mi
    limits:
      cpu: 500m      # Increased to 500m to accommodate Pi4 workload with log collection
      memory: 1536Mi # Increased to 1536Mi to handle all cluster pod logs

  # RBAC
  rbac:
    create: true

  # Service account
  serviceAccount:
    create: true

  # Service
  service:
    enabled: true
    type: ClusterIP

  # Monitoring - expose metrics for Prometheus
  serviceMonitor:
    enabled: true
    additionalLabels:
      release: prometheus
    interval: 60s
